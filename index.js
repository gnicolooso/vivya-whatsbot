// Carrega vari√°veis de ambiente do .env
require('dotenv').config({ path: './variaveis.env' });

// Importa√ß√µes de bibliotecas
const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const axios = require('axios');
const express = require('express');
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid'); // Para gerar nomes de arquivos √∫nicos
const cors = require('cors'); // Para lidar com requisi√ß√µes de diferentes origens

const app = express();

// --- Vari√°veis de Configura√ß√£o e Constantes ---
// Diret√≥rio onde as sess√µes do whatsapp-web.js ser√£o salvas.
// Montado como volume no Railway: /app/.wwebjs_auth
const SESSION_DIR = '/app/.wwebjs_auth';
// ID fixo para a sess√£o do bot. √â CRUCIAL que este ID n√£o mude entre deploys para persist√™ncia.
const CLIENT_ID = "session-bot-principal";
// Caminho completo para o diret√≥rio de sess√£o espec√≠fico deste cliente.
const CLIENT_SESSION_DIR = path.join(SESSION_DIR, `session-${CLIENT_ID}`);

// URL do microservi√ßo de QR Code (ajuste conforme seu deploy do microservi√ßo)
const QR_SERVICE_URL = process.env.QR_SERVICE_URL || 'https://qr-code-viewer-docker-production.up.railway.app';
// URL do webhook do n8n para processar mensagens (ajuste conforme seu webhook)
const N8N_WEBHOOK_URL = process.env.N8N_WEBHOOK_URL || 'https://vivya.app.n8n.cloud/webhook-test/56816120-1928-4e36-9e36-7dfdf5277260';
// URL p√∫blica do seu bot (usada para servir m√≠dia)
const PUBLIC_URL = process.env.PUBLIC_URL || 'http://localhost:8080';

// --- Configura√ß√£o CORS (ADICIONADA/MODIFICADA PARA SEGURAN√áA E TESTES) ---
app.use(cors({
    origin: QR_SERVICE_URL, // Permita especificamente o seu frontend do microservi√ßo
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE', // M√©todos permitidos
    credentials: true, // Se o frontend precisar de cookies/credenciais (geralmente n√£o para este caso)
    optionsSuccessStatus: 204 // Status para preflight OPTIONS
}));
app.use(express.json());

// --- Configura√ß√£o para servir arquivos est√°ticos (MUITO IMPORTANTE!) ---
// Isso permite que as URLs como process.env.PUBLIC_URL/media/{filename} funcionem.
const mediaDir = path.join(__dirname, 'tmp', 'media');
app.use('/media', express.static(mediaDir));

// Garante que o diret√≥rio de m√≠dia existe na inicializa√ß√£o do servidor
if (!fs.existsSync(mediaDir)) {
    fs.mkdirSync(mediaDir, { recursive: true });
}
console.log(`üìÇ Servindo arquivos est√°ticos de: ${mediaDir}`);
// --- Fim da configura√ß√£o de arquivos est√°ticos ---

let client; // Vari√°vel global para o cliente WhatsApp
let isBotInitializing = false; // Flag para evitar inicializa√ß√µes m√∫ltiplas
let isBotReallyConnected = false; 

// Fun√ß√£o para garantir que os diret√≥rios existam
function ensureSessionDirectoriesExist() {
    try {
        if (!fs.existsSync(SESSION_DIR)) {
            console.log(`[INIT] Criando diret√≥rio de sess√£o: ${SESSION_DIR}`);
            fs.mkdirSync(SESSION_DIR, { recursive: true });
            console.log(`[INIT] Diret√≥rio ${SESSION_DIR} criado.`);
        } else {
            console.log(`[INIT] Diret√≥rio de sess√£o ${SESSION_DIR} j√° existe.`);
        }

        if (!fs.existsSync(CLIENT_SESSION_DIR)) {
            console.log(`[INIT] Criando diret√≥rio espec√≠fico do cliente: ${CLIENT_SESSION_DIR}`);
            fs.mkdirSync(CLIENT_SESSION_DIR, { recursive: true });
            console.log(`[INIT] Diret√≥rio ${CLIENT_SESSION_DIR} criado.`);
        } else {
            console.log(`[INIT] Diret√≥rio espec√≠fico do cliente ${CLIENT_SESSION_DIR} j√° existe.`);
        }

        // --- IN√çCIO: Limpeza de Pastas de Sess√£o Antigas e Inconsistentes ---
        // Isso √© crucial para evitar que o LocalAuth se confunda com m√∫ltiplas sess√µes.
        // Itera sobre o diret√≥rio raiz da sess√£o e remove pastas que n√£o sejam a do CLIENT_ID fixo.
        fs.readdirSync(SESSION_DIR).forEach(file => {
            const fullPath = path.join(SESSION_DIR, file);
            if (file.startsWith('session-') && file !== `session-${CLIENT_ID}`) {
                console.warn(`‚ö†Ô∏è [INIT] Removendo pasta de sess√£o antiga/inconsistente: ${fullPath}`);
                fs.rmSync(fullPath, { recursive: true, force: true });
            }
            // O diret√≥rio 'session' sem clientId tamb√©m pode ser um resqu√≠cio.
            if (file === 'session' && fs.statSync(fullPath).isDirectory()) {
                console.warn(`‚ö†Ô∏è [INIT] Removendo diret√≥rio 'session' gen√©rico: ${fullPath}`);
                fs.rmSync(fullPath, { recursive: true, force: true });
            }
        });
        // --- FIM: Limpeza de Pastas de Sess√£o Antigas e Inconsistentes ---

        // Opcional: Para depura√ß√£o, tente listar o conte√∫do via Node.js
        console.log(`[INIT] Conte√∫do atual de ${SESSION_DIR}:`);
        fs.readdirSync(SESSION_DIR).forEach(file => {
            console.log(`  - ${file}`);
        });
        console.log(`[INIT] Conte√∫do atual de ${CLIENT_SESSION_DIR}:`);
        fs.readdirSync(CLIENT_SESSION_DIR).forEach(file => {
            console.log(`  - ${file}`);
        });

    } catch (error) {
        console.error(`‚ùå [INIT] Erro ao garantir diret√≥rios de sess√£o: ${error.message}`);
        process.exit(1); // Interrompe o processo se n√£o conseguir criar os diret√≥rios
    }
}

// Garante que os diret√≥rios de sess√£o existam e limpa sess√µes antigas ANTES de iniciar o cliente.
ensureSessionDirectoriesExist();

/**
 * Inicializa o cliente WhatsApp Web JS.
 * Esta fun√ß√£o deve ser chamada apenas uma vez ou ap√≥s um `client.destroy()`.
 */
function startClient() {
    // Evita inicializa√ß√µes m√∫ltiplas se j√° estiver inicializando
    if (isBotInitializing) {
        console.log('üü° Bot j√° est√° em processo de inicializa√ß√£o. Ignorando nova chamada.');
        return;
    }
    isBotInitializing = true;
    isBotReallyConnected = false; // Resetar o status ao iniciar

    console.log('üü¢ Inicializando cliente WhatsApp Web...');
    client = new Client({
        // Usa LocalAuth com o CLIENT_ID fixo e o dataPath apontando para a raiz do volume
        authStrategy: new LocalAuth({ clientId: CLIENT_ID, dataPath: SESSION_DIR }),
        puppeteer: {
            headless: true,
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage', // √ötil em ambientes Docker com mem√≥ria limitada
                '--disable-accelerated-2d-canvas',
                '--no-first-run',
                '--no-zygote',
                '--single-process' // √ötil para economia de recursos
            ],
            // userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36'
            // Opcional: Especificar o caminho do userDataDir explicitamente pode ajudar
            // Isso for√ßa o Puppeteer a usar a pasta exata do CLIENT_SESSION_DIR
            userDataDir: CLIENT_SESSION_DIR
        }
    });

    client.on('qr', async (qr) => {
        qrcode.generate(qr, { small: true });
        console.log('üì± QR code gerado. Escaneie com o WhatsApp.');
        isBotReallyConnected = false; // N√£o conectado ainda

        try {
            await axios.post(`${QR_SERVICE_URL}/api/qr`, { qr });
            console.log('‚úÖ QR code enviado ao microservi√ßo.');
        } catch (error) {
            console.error('‚ùå Falha ao enviar QR code ao microservi√ßo:', error.message);
        }
    });

    client.on('ready', async () => {
        console.log('‚úÖ Cliente conectado ao WhatsApp!');
        isBotInitializing = false; // Resetar flag ap√≥s conex√£o bem-sucedida
        isBotReallyConnected = true; // Definir como TRUE aqui!
        try {
            await axios.post(`${QR_SERVICE_URL}/api/connected`);
            console.log(`‚úÖ Status de conex√£o enviado ao microservi√ßo. Status = ${client.info.status}`);
        } catch (error) {
            console.error('‚ùå Erro ao atualizar status de conex√£o no microservi√ßo:', error.message);
        }
    });

    client.on('message', async message => {
        if (message.fromMe || message.isStatus || message.isGroupMsg) return;

        try {
            const chat = await message.getChat();
            const contact = await message.getContact();
            const botInfo = client.info; // Informa√ß√µes do cliente/bot

            // Inicializa o payload com informa√ß√µes comuns
            console.log('DEBUG: Inicializa o payload...');
            const payload = {
                // Informa√ß√µes do bot (simulando algumas vari√°veis da API do WhatsApp Business)
                phone_number_id: botInfo.wid.user, // O ID do n√∫mero do bot
                display_phone_number: botInfo.pushname || botInfo.wid.user, // Nome do perfil do bot ou ID

                // Informa√ß√µes do remetente
                from: message.from.split('@')[0], // N√∫mero de telefone do remetente. Remove o "@c.us" do final
                contacts: {
                    profile: {
                        name: contact.pushname || contact.name // Nome do contato no WhatsApp
                    }
                },
                is_group: chat.isGroup,

                // Informa√ß√µes da mensagem
                message_id: message.id.id, // ID √∫nico da mensagem
                timestamp: message.timestamp, // Carimbo de data/hora da mensagem
                message_type: message.type, // Tipo da mensagem (text, image, video, audio, document, sticker, location, etc.)

                // Objetos para conte√∫do espec√≠fico, inicializados vazios
                text: {},
                audio: {},
                video: {},
                image: {},
                document: {},
            };

            // Processamento da m√≠dia
            if (message.hasMedia) {
                const media = await message.downloadMedia();

                if (media) {
                    const extension = media.mimetype.split('/')[1].split(';')[0] || 'bin';
                    const filename = `${Date.now()}-${uuidv4()}.${extension}`; // Nome √∫nico do arquivo
                    const fullPath = path.join(mediaDir, filename); // Usa o diret√≥rio de m√≠dia global

                    fs.writeFileSync(fullPath, Buffer.from(media.data, 'base64'));
                    console.log(`üíæ M√≠dia salva localmente: ${fullPath}`);

                    const mediaUrl = `${PUBLIC_URL}/media/${filename}`;

                    // Popula o objeto de m√≠dia espec√≠fico no payload
                    switch (message.type) {
                        case 'audio':
                        case 'ptt': // Push to talk (√°udio)
                            payload.audio = {
                                mime_type: media.mimetype,
                                filename: message._data?.filename || filename, // Tenta usar o nome original, fallback para o gerado
                                url: mediaUrl
                            };
                            break;
                        case 'image':
                            payload.image = {
                                mime_type: media.mimetype,
                                filename: message.caption || message._data?.filename || filename, // Legenda, nome original ou gerado
                                url: mediaUrl
                            };
                            break;
                        case 'video':
                            payload.video = {
                                mime_type: media.mimetype,
                                filename: message.caption || message._data?.filename || filename, // Legenda, nome original ou gerado
                                url: mediaUrl
                            };
                            break;
                        case 'document':
                            payload.document = {
                                mime_type: media.mimetype,
                                filename: message.filename || message._data?.filename || filename, // Nome original, ou gerado
                                url: mediaUrl
                            };
                            break;
                        default:
                            payload.other_media = {
                                mime_type: media.mimetype,
                                filename: message._data?.filename || filename,
                                url: mediaUrl
                            };
                            console.log(`‚ö†Ô∏è Tipo de m√≠dia n√£o tratado especificamente: ${message.type}`);
                            break;
                    }
                }
            } else if (message.type === 'chat') { // Mensagem de texto simples
                payload.text.body = message.body;
            } else {
                payload.unknown_message_data = message;
                console.log(`‚ö†Ô∏è Tipo de mensagem n√£o tratado: ${message.type}`);
            }

            try {
                console.log('DEBUG: Tentando enviar payload para n8n...');
                await axios.post(N8N_WEBHOOK_URL, payload);
                console.log('DEBUG: Payload enviado para n8n com sucesso.');
            } catch (error) {
                console.error('DEBUG: Erro ao enviar payload para n8n:', error.message);
            }

        } catch (error) {
            console.error('‚ùå Erro no webhook ou no processamento da mensagem:', error.message);
        }
    });

    client.on('auth_failure', async (msg) => {
        console.error('üîê Falha de autentica√ß√£o:', msg);
        console.error('Reinicializando sess√£o ap√≥s falha de autentica√ß√£o...');
        isBotInitializing = false; // Permitir nova inicializa√ß√£o
        isBotReallyConnected = false; // N√£o conectado
        await client.destroy(); // Destr√≥i o cliente atual
        // N√£o √© necess√°rio remover arquivos de sess√£o aqui, pois o destroy() √© suficiente
        // e queremos que o LocalAuth tente reusar a mesma pasta na pr√≥xima inicializa√ß√£o.
        startClient(); // Tenta iniciar novamente, possivelmente gerando novo QR
    });

    client.on('disconnected', async (reason) => {
        console.warn(`‚ö†Ô∏è Cliente desconectado: ${reason}`);
        isBotInitializing = false; // Permitir nova inicializa√ß√£o
        isBotReallyConnected = false; // N√£o conectado
        if (client && client.pupBrowser) { // Verifica se o navegador ainda est√° aberto antes de tentar destruir
            await client.destroy();
            console.log('‚úÖ Cliente destru√≠do ap√≥s desconex√£o.');
        } else {
            console.log('‚ÑπÔ∏è Cliente j√° estava fechado ou n√£o tinha navegador para destruir.');
        }
        startClient(); // Tenta iniciar novamente
    });

    // Adicionar um evento de estado para debug
    client.on('change_state', state => {
        console.log('üîÑ Estado do cliente WhatsApp-web.js mudou para:', state);
        // Poss√≠veis estados: CONNECTED, DISCONNECTED, INITIALIZING, QRCODE_RECEIVED, AUTHENTICATING,
        // AUTH_FAILURE, LOADING_CHATTS
        if (state === 'CONNECTED') {
            isBotReallyConnected = true;
        } else {
            isBotReallyConnected = false;
        }
    });    

    client.initialize();
}

// Inicia o cliente na inicializa√ß√£o do aplicativo Node.js
startClient();

// --- Fun√ß√µes Auxiliares para Verificar o Status do Cliente ---
// Centraliza a l√≥gica de verifica√ß√£o de conex√£o
function isClientConnected() {
    // client deve existir e estar conectado
    return isBotReallyConnected && client; 
}

// --- Endpoints HTTP do Bot ---

// Endpoint raiz
app.get('/', (req, res) => {
    res.send('ü§ñ Bot do WhatsApp est√° rodando!');
});

/**
 * Endpoint para reset manual da sess√£o.
 * Este endpoint ir√° destruir a sess√£o atual e apagar seus arquivos,
 * for√ßando o bot a gerar um novo QR Code na pr√≥xima inicializa√ß√£o.
 */
app.post('/reset-session', async (req, res) => {
    console.log('üîÑ Requisi√ß√£o de reset de sess√£o recebida no bot.');
    try {
        // 1. Destruir o cliente WhatsApp Web JS se ele estiver ativo
        if (client && client.pupBrowser) {
            console.log('üîå Tentando destruir o cliente WhatsApp Web.');
            await client.destroy();
            console.log('‚úÖ Cliente WhatsApp Web destru√≠do.');
        } else {
            console.log('‚ÑπÔ∏è Cliente WhatsApp Web n√£o estava ativo para destruir.');
        }

        // 2. Apagar os arquivos da sess√£o persistida para for√ßar um novo QR Code
        if (fs.existsSync(CLIENT_SESSION_DIR)) {
            console.log(`üßπ Removendo arquivos de sess√£o de: ${CLIENT_SESSION_DIR}`);
            fs.rmSync(CLIENT_SESSION_DIR, { recursive: true, force: true });
            console.log('‚úÖ Arquivos de sess√£o removidos.');
        } else {
            console.log('‚ÑπÔ∏è Diret√≥rio de sess√£o n√£o encontrado para remover.');
        }

        // 3. Resetar a flag de inicializa√ß√£o para permitir um novo start
        isBotInitializing = false;

        // 4. Enviar a resposta de sucesso
        res.status(200).json({ message: 'Sess√£o do bot resetada e arquivos removidos. O bot tentar√° se reconectar e gerar√° um novo QR Code.' });
        console.log('‚úÖ Resposta de reset enviada ao microservi√ßo.');

        // 5. Iniciar o cliente NOVAMENTE para for√ßar um novo QR Code.
        // Pequeno atraso para garantir que a resposta HTTP foi enviada
        setTimeout(() => {
            console.log('üöÄ Iniciando novamente o cliente WhatsApp Web para gerar novo QR.');
            startClient(); // Chama a fun√ß√£o que inicializa o client com o ID fixo
        }, 1000);

    } catch (err) {
        console.error('‚ùå Erro inesperado ao resetar sess√£o manualmente:', err);
        if (!res.headersSent) {
            res.status(500).json({ error: 'Erro interno ao tentar resetar sess√£o.', details: err.message });
        }
    }
});

/**
 * Endpoint para o microservi√ßo solicitar um QR Code.
 * √ötil para sincroniza√ß√£o na inicializa√ß√£o ou ap√≥s falhas.
 */
app.post('/api/request-qr', async (req, res) => {
    console.log('üîÑ Solicita√ß√£o de QR code recebida do microservi√ßo.');
    // Se o cliente n√£o estiver conectado ou estiver inicializando, force uma nova inicializa√ß√£o
    if (!client || !client.info || client.info.status !== 'CONNECTED') {
        console.log('Bot n√£o conectado ou inicializado. For√ßando inicializa√ß√£o para gerar QR.');
        startClient(); // Tenta iniciar/re-inicializar o cliente
        res.status(200).send('Bot instru√≠do a iniciar/gerar QR.');
    } else {
        console.log('Bot j√° conectado, n√£o √© necess√°rio gerar QR.');
        res.status(200).send('Bot j√° conectado.');
    }
});

// --- Endpoints para Controle de Estado do Chat (Digitando/Gravando/Limpar) ---

app.post('/api/set-typing-state', async (req, res) => {
    const { to } = req.body;
    if (!to) return res.status(400).json({ error: 'Par√¢metro "to" √© obrigat√≥rio.' });

    if (!isClientConnected()) { 
        console.warn(`‚ö†Ô∏è Tentativa de definir estado de digita√ß√£o para ${to}, mas o bot n√£o est√° conectado. isBotReallyConnected: ${isBotReallyConnected}. client.info.status: ${client?.info?.status || 'N/A'}`);
        return res.status(500).json({ error: 'Bot n√£o est√° conectado ao WhatsApp. Tente novamente mais tarde.' });
    }

    try {
        const chat = await client.getChatById(to);
        if (chat) {
            await chat.sendStateTyping();
            console.log(`üí¨ Definido estado 'digitando' para: ${to}`);
            res.status(200).json({ success: true, message: 'Estado de digita√ß√£o definido.' });
        } else {
            console.warn(`‚ö†Ô∏è Chat n√£o encontrado para o ID: ${to}. N√£o foi poss√≠vel definir o estado de digita√ß√£o.`);
            res.status(404).json({ success: false, error: 'Chat n√£o encontrado.' });
        }
    } catch (error) {
        console.error(`‚ùå Erro ao definir estado 'digitando' para ${to}:`, error.message);
        res.status(500).json({ success: false, error: 'Falha ao definir estado de digita√ß√£o.', details: error.message });
    }
});

app.post('/api/set-recording-state', async (req, res) =>  {
    const { to } = req.body;
    if (!to) return res.status(400).json({ error: 'Par√¢metro "to" √© obrigat√≥rio.' });
    if (!isClientConnected()) { 
        console.warn(`‚ö†Ô∏è Tentativa de definir estado de digita√ß√£o para ${to}, mas o bot n√£o est√° conectado. isBotReallyConnected: ${isBotReallyConnected}. client.info.status: ${client?.info?.status || 'N/A'}`);
        return res.status(500).json({ error: 'Bot n√£o est√° conectado ao WhatsApp. Tente novamente mais tarde.' });
    }
    try {
        const chat = await client.getChatById(to);
        if (chat) {
            await chat.sendStateRecording();
            console.log(`üé§ Definido estado 'gravando' para: ${to}`);
            res.status(200).json({ success: true, message: 'Estado de grava√ß√£o definido.' });
        } else {
            console.warn(`‚ö†Ô∏è Chat n√£o encontrado para o ID: ${to}. N√£o foi poss√≠vel definir o estado de grava√ß√£o.`);
            res.status(404).json({ success: false, error: 'Chat n√£o encontrado.' });
        }
    } catch (error) {
        console.error(`‚ùå Erro ao definir estado 'gravando' para ${to}:`, error.message);
        res.status(500).json({ success: false, error: 'Falha ao definir estado de grava√ß√£o.', details: error.message });
    }
});

app.post('/api/clear-chat-state', async (req, res) => {
    const { to } = req.body;
    if (!to) return res.status(400).json({ error: 'Par√¢metro "to" √© obrigat√≥rio.' });
    if (!isClientConnected()) { 
        console.warn(`‚ö†Ô∏è Tentativa de definir estado de digita√ß√£o para ${to}, mas o bot n√£o est√° conectado. isBotReallyConnected: ${isBotReallyConnected}. client.info.status: ${client?.info?.status || 'N/A'}`);
        return res.status(500).json({ error: 'Bot n√£o est√° conectado ao WhatsApp. Tente novamente mais tarde.' });
    }
    try {
        const chat = await client.getChatById(to);
        if (chat) {
            await chat.clearState();
            console.log(`‚ùå Estado de chat limpo para: ${to}`);
            res.status(200).json({ success: true, message: 'Estado de chat limpo.' });
        } else {
            console.warn(`‚ö†Ô∏è Chat n√£o encontrado para o ID: ${to}. N√£o foi poss√≠vel limpar o estado do chat.`);
            res.status(404).json({ success: false, error: 'Chat n√£o encontrado.' });
        }
    } catch (error) {
        console.error(`‚ùå Erro ao limpar estado de chat para ${to}:`, error.message);
        res.status(500).json({ success: false, error: 'Falha ao limpar estado de chat.', details: error.message });
    }
});

/**
 * Endpoint para enviar mensagens de WhatsApp (texto ou m√≠dia).
 * Recebe 'to', 'message' (para texto) e/ou 'mediaType', 'mediaUrl', 'caption', 'filename' (para m√≠dia).
 */
app.post('/api/send-whatsapp-message', async (req, res) => {
    const { to, message, mediaType, mediaUrl, caption, filename } = req.body;

    if (!to) {
        return res.status(400).json({ error: 'Par√¢metro "to" √© obrigat√≥rio.' });
    }
    if (!client || !client.info || client.info.status !== 'CONNECTED') {
        console.error('‚ùå Cliente WhatsApp n√£o est√° pronto ou conectado para enviar mensagem.');
        return res.status(500).json({ error: 'Bot n√£o est√° conectado ao WhatsApp.' });
    }

    try {
        if (mediaType && mediaUrl) {
            const media = await MessageMedia.fromUrl(mediaUrl);
            let options = {};
            if (caption) options.caption = caption;
            if (filename) options.filename = filename;

            switch (mediaType) {
                case 'image':
                case 'video':
                case 'document':
                    await client.sendMessage(to, media, options);
                    console.log(`‚úÖ ${mediaType} enviado para ${to} da URL: ${mediaUrl}`);
                    break;
                case 'audio':
                case 'ptt':
                    options.sendAudioAsVoice = true; // Envia √°udio como grava√ß√£o de voz
                    await client.sendMessage(to, media, options);
                    console.log(`‚úÖ √Åudio (PTT) enviado para ${to} da URL: ${mediaUrl}`);
                    break;
                default:
                    console.warn(`‚ö†Ô∏è Tipo de m√≠dia desconhecido: ${mediaType}. Tentando enviar como mensagem de texto.`);
                    if (message) {
                        await client.sendMessage(to, message);
                        console.log(`‚úÖ Mensagem de texto enviada para ${to}: ${message}`);
                    } else {
                        return res.status(400).json({ error: 'Tipo de m√≠dia n√£o suportado e nenhuma mensagem de texto fornecida.' });
                    }
            }
        } else if (message) {
            await client.sendMessage(to, message);
            console.log(`‚úÖ Mensagem de texto enviada para ${to}: ${message}`);
        } else {
            return res.status(400).json({ error: 'Nenhuma mensagem de texto ou m√≠dia fornecida para enviar.' });
        }

        res.status(200).json({ success: true, message: 'Mensagem enviada com sucesso.' });
    } catch (error) {
        console.error(`‚ùå Erro ao enviar mensagem para ${to}:`, error.message);
        res.status(500).json({ success: false, error: 'Falha ao enviar mensagem.', details: error.message });
    }
});


console.log('üü° Tentando iniciar servidor Express...');
// Inicializa servidor na porta correta
const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
    console.log(`üöÄ Servidor rodando na porta ${PORT}`);
});

// Captura falhas n√£o tratadas
process.on('unhandledRejection', (reason, p) => {
    console.error('üö® Erro n√£o tratado (Promise Rejection):', reason);
});

process.on('uncaughtException', (err) => {
    console.error('üö® Exce√ß√£o n√£o capturada:', err);
    process.exit(1); // √â uma boa pr√°tica sair para permitir que o Railway reinicie o app
});